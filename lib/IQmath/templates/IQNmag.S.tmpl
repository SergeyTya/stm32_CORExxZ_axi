//*****************************************************************************
//
// IQmag.S - Fixed point magnitude
//
// Copyright (c) 2010 Texas Instruments Incorporated.  All rights reserved.
// TI Information - Selective Disclosure
//
//*****************************************************************************

//*****************************************************************************
//
// Function:   _IQNmag
//
//*****************************************************************************
//
// C Usage:    extern long _IQNmag(long X, long Y); // with rounding & sat
//
//-----------------------------------------------------------------------------
//
// On Entry:   r0    = X in IQ format
//             r1    = Y in IQ format
//
// Regs Used:  r0-r4
//             r4 is pushed/popped to prevent clobbering.
//
// On Exit:    r0    = sqrt(X) result in IQ format
//             r0    = 0 if input is -ve or 0
//
//                      Note: The square root of any number will never
//                            overflow, hence saturation is not required.
//
// Q range:    30 to 1
//
//-----------------------------------------------------------------------------
//
// Algorithm:  The procedure for calculating "Y = sqrt(X)" is as follows:
//
//      Step 1)  Calculate Z = isqrt(X).  See _IQisqrt.S for details.
//
//      Step 2)  Calculate Y = sqrt(X) = X*isqrt(X) = Z*x
//
//      Step 3) Denormalize result and round
//
//##### INTERNAL BEGIN #####
//-----------------------------------------------------------------------------
//
// Benchmark:
//
//  Q <= 20, L is even :
//  Q <= 20, L is odd  :
//  Q >  20, L is even :
//  Q >  20, L is odd  :
//  Negative or Zero   :
//  Overflow           :
//
//##### INTERNAL END #####
//*****************************************************************************
__PREAMBLE__
//*****************************************************************************
//
// The isqrt table is used.
//
//*****************************************************************************
    __IMPORT__ isqrt_table

//$ BEGIN_UNROLL _QQ_ 1 to 30
//*****************************************************************************
//
// _IQ_QQ_mag
//
//*****************************************************************************
    __SECTION__ _IQ_QQ_mag
    __EXPORT__ _IQ_QQ_mag__THUMB_LABEL__
_IQ_QQ_mag__LABEL__
    //
    // Save non-volatile registers.
    //
    push    {r4, lr}

    //
    // Sum of Squares
    // Keep 64 bit version in r12lr
    // Place 32 bit version in r0
    //
    smull   r12, lr, r0, r0
    smlal   r12, lr, r1, r1

    //
    // Place upper 32 used bits of result into r0, effectively creating a
    // normalized Q32 representation.
    // This is implemented as a 64 bit clz shift followed
    // by a 32 bit clz shift.
    // Total shift amount is stored in r3
    //
    clz     r3, lr
    rsb     r2, r3, #32
    lsrs    r0, r12, r2
    lsl     r1, lr, r3
    adcs    r0, r0, r1
    ittt    pl
        clzpl   r2, r0
        lslpl   r0, r0, r2
        addpl   r3, r2, r3

    //
    // If the result is 0, bail early.
    // We are guaranteed that the result is not negative,
    // so those checks are omitted.
    //
    teq     r0, #0
    it      eq
        popeq  {r4, pc}

    //
    // Table Lookup for Initial Estimate
    // Uses  the top 9 actual bits as index
    // The top bit (#10) is ignored, because it is always one.  This is done
    // with the -0x800.  (0x200 is 10th bit, shift up two for 4 byte words).
    //
    lsr     r2, r0, #(32 - 10)
    ldr     r1, isqrt_table__QQ_
    ldr     r1, [r1, r2, lsl #2]

    //
    // Newton Raphson Iteration  #1
    // 11-17 Cycles
    // r0 is Q32, r1 is Q31
    //
    umull   r4, r2, r0, r1
    umull   r4, r2, r2, r1
    rsb     r2, r2, #0xC0000000
    umull   r4, r1, r2, r1
    lsl     r1, r1, #1

    //
    // Newton Raphson Iteration  #2
    // 11-17 Cycles
    //
    umull   r4, r2, r0, r1
    umull   r4, r2, r2, r1
    rsb     r2, r2, #0xC0000000
    umull   r4, r1, r2, r1
    lsl     r1, r1, #1

    //
    // Prepare to Denormalize result
    // r3 stores the necessary shift.
    //
    subs    r3, r3, #2
    bmi     mag_will_overflow_QQ_
    asrs    r3, r3, #1

    //
    // Correct by sqrt(2) if carry bit is set
    // This is due to the normalization to (1.0 0.5) instead of (1.0 0.25)
    itt     cs
        ldrcs   r2, sqrt_half__QQ_
        umullcs r2, r1, r2, r1

    //
    // Multiply isqrt(x) by x to get sqrt(x)
    //
    umull   r4, r0, r0, r1

    //
    // Actually denormalize per above preparation
    // Round result
    // Note:  If r3 == 0, no rounding is performed.  This potentially creates
    // an additional count worth of error if the result is nearly saturated.
    // The extra execution time to check for this is not worthwhile.
    //
    lsrs    r0, r0, r3
    adc     r0, r0, #0

    //
    // Restore r4 and return.
    ///
    pop     {r4, pc}

    //
    // The result will overflow.
    //
mag_will_overflow_QQ___LABEL__
    mvn     r0, #0x80000000
    pop     {r4, pc}

    //
    // The literal pool.
    //
    __LITERALS__
isqrt_table__QQ___LABEL__
    __WORD__ isqrt_table - 0x800
sqrt_half__QQ___LABEL__
    __WORD__ 0xb504f334         // sqrt(1/2) in Q32

//$ END_UNROLL _QQ_
    __END__
