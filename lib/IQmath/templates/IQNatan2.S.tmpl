//******************************************************************************
//
// IQatan2.S - Fixed point calculation of atan2 in radians
//
// Copyright (c) 2010 Texas Instruments Incorporated.  All rights reserved.
// TI Information - Selective Disclosure
//
//******************************************************************************

//******************************************************************************
//
// Function:   _IQNatan2
//
//******************************************************************************
//
// C Usage:    extern long _IQNatan2(long y,long x);
//
//-----------------------------------------------------------------------------
//
// On Entry:   r0    = y in IQ format
//             r1    = x in IQ format
//
// Regs Used:
//
// On Exit:    r0    = atan2(y,x)
//
//
// Q range:    29 to 1
//
//-----------------------------------------------------------------------------
//
// Algorithm:  The procedure for calculating "Z = atan2(y,x)" is as follows:
//
// Algorithm:
//          Step 1) Take the absolute value of both inputs and store sign
//                  information
//
//          Step 2) Choose whether to calculate as Z = atan(x/y)
//                                              or Z = pi/2-acot(y/x)
//                  This is done to keep the calculated ratio within
//                  representable limits: [0,1)
//                  if |x|>|y|
//                      Numerator   = |y|
//                      Denominator = |x|
//                  else
//                      Numerator   = |x|
//                      Denominator = |y|
//
//          Step 3) Ratio = Numerator / Denominator : [0,1)
//
//          Step 4) Use the upper 8 bits of Ratio to look up coefficients for
//                  the approximating polynomial.
//
//          Step 5) Calculate the appoximating polynomial.
//              partial_angle : [0,pi/4)
//
//          Step 6) Place the resulting angle in the correct octant.
//              if |x|>|y|
//                  partial_angle = pi/2-partial_angle
//
//              if x>=0 and y>=0
//                  result = partial_angle
//              if x>=0 and y>=0 and |x|<|y|
//                  result = - partial_angle
//              if x<0  and y>=0 and |x|<|y|
//                  result = pi - partial_angle
//              if x>=0 and y>=0 and |x|>|y|
//                  result = pi + partial_angle
//
//-----------------------------------------------------------------------------
//
// Benchmark:
//      Equal Inputs  :  40-48 Cycles
//      x=y=0         :  20 Cycles
//      Octant 1      :  99 Cycles
//      Octant 2      : 103 Cycles
//      Octant 3      : 105 Cycles
//      Octant 4      : 100 Cycles
//      Octant 5      : 103 Cycles
//      Octant 6      : 107 Cycles
//      Octant 7      : 105 Cycles
//      Octant 8      : 101 Cycles
//  Note:
//   Inputs of less than 16 bits process up to 2 cycles quicker.
//   Some regions within an octant will process up to 2 cycles quicker; This
//   happens due to early break out from a UMULL for small inputs.
//
//*****************************************************************************
__PREAMBLE__
//*****************************************************************************
//
// The division and atan2PU tables are used.
//
//*****************************************************************************
    __IMPORT__ div_table
    __IMPORT__ atan2PU_table

//$ BEGIN_UNROLL _QQ_ 1 to 29
//*****************************************************************************
//
// _IQ_QQ_atan2
//
//*****************************************************************************
    __SECTION__ _IQ_QQ_atan2
    __EXPORT__ _IQ_QQ_atan2__THUMB_LABEL__
_IQ_QQ_atan2__LABEL__
    //
    // Take absolute values of inputs and store sign information in r12.
    // r12[29] =  Y < 0
    // r12[30] =  X < 0
    // r12[31] = |Y|>|X|
    //
    ands    r12, r0, #0x80000000
    it      ne
        rsbne   r0, r0, #0
    lsls    r2, r1, #1
    it      cs
        rsbcs   r1, r1, #0
    rrx     r12, r12

    //
    // Place the larger of the two inputs in r1, the smaller in r0.
    // Remember this decision in R12.
    //
    cmp     r0, r1
    rrx     r12, r12
    beq     operands_are_equal__QQ_
    ittt    hi
        movhi   r2, r0
        movhi   r0, r1
        movhi   r1, r2

    //
    // Divide r0 by r1 to find the ratio
    // Save state to stack.
    //
    push    {r4, r5}

    //
    // Normalize denominator to (1.0 0.5) in Q32
    //
    clz     r5, r1
    lsl     r1, r1, r5

    //
    //    r0 numerator GQ       r1 normalized denominator Q32
    //    r2 1/denominator Q31  r3 normalization n I
    //
    // Table Lookup for Initial Estimate
    // Uses  the top 9 actual bits as index
    // The top bit (#10) is ignored, because it is always one.  This is done
    // with the -0x800.  (0x200 is 10th bit, shift up two for 4 byte words).
    //
    lsr     r2, r1, #(32 - 10)
    ldr     r3, div_table__QQ_
    ldr     r2, [r3, r2, lsl #2]

    //
    // Newton Raphson Iteration  #1
    // Dm = 2(Dm - Dm^2*Dnorm/2)
    // r2 = 2(r2 - r2^2*r1/2)
    // r1:Q32, r2:Q31
    //
    umull   r4, r3, r2, r2
    umull   r4, r3, r3, r1
    sub     r3, r2, r3
    lsl     r2, r3, #1

    //
    // Newton Raphson Iteration  #2
    // 8-12 Cycles
    //
    umull   r4, r3, r2, r2
    umull   r4, r3, r3, r1
    sbc     r2, r2, r3

    //
    // Multiply numerator by 1/denominator:
    // r2 is in Q29
    //
    umull   r1, r0, r0, r2

    //
    // Prepare the shift values.
    // Put the result in Q31.
    // Do not round, for fear of overflow.
    //
    add     r5, r5, #2
    rsb     r4, r5, #32
    lsr     r1, r1, r4
    lsl     r0, r0, r5
    add     r0, r0, r1

    //
    // r0 holds the calculated ratio of the inputs as UQ32.
    // r1 - r5 are available for use, r4 is saved on the stack.
    // r12 contains information on which octant the final result should be in.
    //
    // Use the top 8 bits of the ratio as a table index into the lookup table.
    // Multiply it by 3 because there are 3 coefficients per index value.
    //
    // There may be a wasted cycle here; It adds the offset to the table index
    // separately. This is so that r3 is updated to the appropriate position
    // for the next 2 loads.
    //
    lsr     r2, r0, #(32 - 8)
    add     r2, r2, r2, lsl #1
    ldr     r3, atan2PU_table__QQ_
    add     r3, r3, r2, lsl #2

    //
    // r0       ratio of inputs in UQ32
    // {r1,r2}
    // r3       Pointer into lookup table
    // r4       Loaded coefficient
    //
    ldr     r4, [r3]
    umull   r2, r1, r4, r0
    ldrd    r4, r5, [r3, #4]!
    sub     r4, r4, r1
    umull   r2, r1, r0, r4
    add     r0, r1, r5

    //
    // Divide by four to get to Q30.  Consider working this into coefficients
    // to save one cycle.
    //
    lsr     r0, r0, #2

    //
    // r0 : atanPU of input, within the first octant, UQ30.  [0,.5)
    // R12: Destination Octant >
    //      r12[31] = |Y|>|X|
    //      r12[30] =  X < 0
    //      r12[29] =  Y < 0
    //
    //  if( y < 0 ) r0 = 0.0 - r0
    //
equal_operands_reentry_point__QQ___LABEL__
    lsls    r12, r12, #1

    //
    //  if(|y|>|x|) r0 = 0.5 - r0
    //
    it      cs
        rsbcs   r0, r0, #0x20000000

    //
    //  if( x < 0 ) r0 = 1.0 - r0
    //
    it      mi
        rsbmi   r0, r0, #0x40000000

    //
    //  if( y < 0 ) r0 = 0.0 - r0
    //
    lsls    r12, r12, #1
    it      mi
        rsbmi   r0, r0, #0

    //
    // Multiply by pi to return to radians from CPU.
    //
    ldr     r1, piq29__QQ_
    smull   r1, r0, r1, r0

    //
    // Shift result to normalize from Q27.
    //
#if _QQ_ < 27
    asrs    r0, r0, #(27 - _QQ_)
    adc     r0, r0, #0
#endif
#if _QQ_ > 27
    lsrs    r1, r1, #(32 - (_QQ_ - 27))
    adc     r0, r1, r0, lsl #(_QQ_ - 27)
#endif
#if 0
    //asrs    r0, r0, #(31 - _QQ_)
    //adc     r0, r0, #0
#endif
    pop     {r4, r5}
    bx      lr

    //
    // If the operands are (0,0), the answer is defined to be zero.  This is
    // consistent with the standard C definition.
    //
operands_are_equal__QQ___LABEL__
    teq     r0, #0
    it      eq
        bxeq    lr

    //
    // If the operands are equal but nonzero, the result is one of the 45's
    // Skip the division etc and re-enter normal program flow just before
    // octant determination after setting the "result" to an eighth PU radian.
    //
    // Push r4 and r5 for consistency, even though we don't use them in this
    // execution path.
    //
    mov     r0, #0x10000000
    push    {r4, r5}
    b       equal_operands_reentry_point__QQ_

    //
    // The literal pool.
    //
    __LITERALS__
piq29__QQ___LABEL__
    __WORD__ 0x6487ed51         // pi in Q29
div_table__QQ___LABEL__
    __WORD__ div_table - 0x800
atan2PU_table__QQ___LABEL__
    __WORD__ atan2PU_table

//$ END_UNROLL _QQ_
    __END__
