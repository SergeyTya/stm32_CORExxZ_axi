//*****************************************************************************
//
// IQrsmpy.S - Fixed point multiply with rounding and saturation
//
// Copyright (c) 2010 Texas Instruments Incorporated.  All rights reserved.
// TI Information - Selective Disclosure
//
//*****************************************************************************

//*****************************************************************************
//
// Function:   _IQNrsmpy
//
//*****************************************************************************
//
// C Usage:    extern long _IQNrsmpy(long M, long X); // with round and sat
//
//-----------------------------------------------------------------------------
//
// On Entry:   r0     = A in IQ format
//             r1     = B in IQ format
//
// Regs Used:  r0, r1
//
// On Exit:    r0     = A*B stored as IQ
//
// Q range:    30 to 1
//
//-----------------------------------------------------------------------------
//
// Algorithm:  The integer portion of the IQ*I32 number is calculated
//             as follows:
//
//                result = saturate ( (A*B >> q_value)+result[-1] );
//
//-----------------------------------------------------------------------------
//
// Benchmark:
//
// Cycles = 5-9 cycles, not counting call
//
//*****************************************************************************
__PREAMBLE__
//$ BEGIN_UNROLL _QQ_ 1 to 30
//*****************************************************************************
//
// _IQ_QQ_rsmpy
//
//*****************************************************************************
    __SECTION__ _IQ_QQ_rsmpy
    __EXPORT__ _IQ_QQ_rsmpy__THUMB_LABEL__
_IQ_QQ_rsmpy__LABEL__
    //
    // Perform a 32x32-> 64 bit signed multiply
    //
    smull   r0, r1, r0, r1

    //
    // Test for Saturation
    // This is done by shifting the high 32 down so that only
    // saturating bits are present.  Unsaturated, this will be
    // all ones or all zeros.  Add 1 and shift down, unsaturated
    // will create all zeros.
    //
    // The typical saturate instruction takes just as long, but
    // does not provide a sign flag.
    //
#if _QQ_ > 1
    asr     r2, r1, #(_QQ_ - 1)
    add     r2, r2, #1
#endif
#if _QQ_ < 2
    add     r2, r1, #1
#endif
    asr     r3, r2, #1
    cbnz    r3, saturated_QQ_

    //
    // Shift the lower 32 bits of the result down by Q
    // Also, update Carry flag to indicate whether or not to round
    //
    lsrs    r0, r0, #_QQ_

    //
    // Shift the upper 32 by ~Q
    // Add the upper and lower bits together
    // Add the carry flag in to round
    //
    adc     r0, r0, r1, lsl #(32 - _QQ_)

    //
    // Return to the caller.
    //
    bx      lr

    //
    // Saturated Branch
    // R3 is used as a sign flag.  Shifted down, it is pure zeros or ones.
    // This is XORed with a constant to create the return values.
saturated_QQ___LABEL__
    mvn     r0, #0x80000000
    eor     r0, r0, r3, asr #32
    bx      lr

    //
    // Make sure that the end of the section is word aligned.
    //
    __ALIGN__

//$ END_UNROLL _QQ_
    __END__
